# 🧠 명령어 병렬 처리 기법

이번 절에서는 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시키는 기법인 **명령어 병렬 처리 기법**을 알아봅니다.

대표적인 기법:
- **명령어 파이프라이닝**
- **슈퍼스칼라**
- **비순차적 명령어 처리**

---

## 🔁 명령어 파이프라이닝

명령어 처리 과정을 클럭 단위로 나누면 보통 다음과 같습니다:

1. 명령어 인출  
2. 명령어 해석  
3. 명령어 실행  
4. 결과 저장  

> 💡 **핵심 개념:**  
> 각 단계가 겹치지만 않는다면 CPU는 이들을 동시에 실행할 수 있음 → 생산 라인처럼

예시:
- 한 명령어를 '인출'하는 동안 → 다른 명령어를 '실행'  
- '실행'하는 동안 → 결과 '저장'

**➡️ 이처럼 명령어들을 동시에 처리하는 기법을 "명령어 파이프라이닝"이라고 합니다.**

### 📷 파이프라이닝 구조 예시

![명령어 파이프라이닝 이미지](https://github.com/user-attachments/assets/08ac14fc-0544-43e6-8dae-8a54ce0eb2d1)

---

### ⚠️ 파이프라이닝의 위험 요소 (Pipeline Hazards)

파이프라이닝은 성능을 향상시키지만, 다음과 같은 위험 요소로 인해 실패할 수도 있습니다:

#### 1. 데이터 위험 (Data Hazard)

- 명령어 간 데이터 의존성으로 인해 발생
- 예시:
  ```plaintext
  명령어 1: R1 <- R2 + R3
  명령어 2: R4 <- R1 + R5
→ R1 값이 필요하므로, 명령어 1 실행 후에야 명령어 2 실행 가능

#### 2. 제어 위험 (Control Hazard)
- 분기 명령어 등으로 프로그램 흐름이 갑자기 바뀌면  
  → 미리 인출된 명령어들이 무효화됨

#### 3. 구조적 위험 (Structural Hazard)
- 서로 다른 명령어가 동시에 같은 하드웨어 자원(ALU, 레지스터 등)을 사용하려 할 때 발생

---

## ⚙️ 슈퍼스칼라 (Superscalar)

- 여러 개의 파이프라인을 통해 동시에 여러 명령어를 처리 가능  
- 파이프라이닝은 단일 파이프라인으로도 가능하지만  
  → 오늘날 대부분의 CPU는 여러 파이프라인을 사용함  
- 이러한 구조를 **슈퍼스칼라(Superscalar) 구조**라고 하며,  
  해당 구조의 CPU를 **슈퍼스칼라 프로세서** 또는 **슈퍼스칼라 CPU**라고 함

📷 **슈퍼스칼라 구조 예시**  
![슈퍼스칼라 구조](https://github.com/user-attachments/assets/f4863300-26ea-4b68-a283-592a84e0633e)

---

## 🔀 비순차적 명령어 처리 (Out-of-Order Execution)

- 명령어를 순서대로 실행하지 않고, 실행 가능한 명령어부터 처리하는 방식  
- 명령어 사이에 **의존성이 없는 경우**  
  → 나중 명령어라도 먼저 실행하여 병목을 줄임  
- 즉, **파이프라인이 멈추지 않도록 합법적인 새치기를 허용하는 기법**
