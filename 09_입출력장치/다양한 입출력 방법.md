# 다양한 입출력 방법

## 프로그램 입출력
- 프로그램 속 명령어로 입출력장치를 제어
- 입출력 명령어를 통해 장치 컨트롤러와 상호작용
- **CPU**가 장치 컨트롤러의 레지스터 값을 읽고 씀으로써 입출력 수행

### 예시: 메모리 → 하드 디스크 백업
1. CPU가 하드 디스크 컨트롤러의 **제어 레지스터**에 쓰기 명령
2. 하드 디스크 컨트롤러는 상태 확인 → **상태 레지스터**에 준비 완료 표시
3. CPU는 주기적으로 상태 레지스터 읽음
4. 준비 완료되면, CPU는 데이터를 **데이터 레지스터**에 씀
5. 백업이 끝나지 않았으면 1번부터 반복, 끝났으면 종료

📌 **CPU는 장치 컨트롤러의 레지스터를 어떻게 아는가?**  
→ 메모리 맵 입출력, 고립형 입출력 방식으로 해결

---

## 프로그램 입출력 방식

### 메모리 맵 입출력 (Memory-mapped I/O)
- 메모리 주소 공간과 입출력 주소 공간을 **하나로 통합**
- **메모리 접근 명령어 = 입출력 접근 명령어**

#### 예시
| 주소 | 기능 |
|------|------|
| 516  | 프린터 컨트롤러 데이터 레지스터 |
| 517  | 프린터 컨트롤러 상태 레지스터 |
| 518  | 하드 디스크 컨트롤러 데이터 레지스터 |
| 519  | 하드 디스크 컨트롤러 상태 레지스터 |

- `517번지 읽기 = 프린터 상태 확인`
- `518번지에 a 쓰기 = 하드 디스크 쓰기`

---

### 고립형 입출력 (Isolated I/O)
- **메모리 공간**과 **입출력 공간**을 **분리**
- 입출력 전용 명령어 사용 (입출력 읽기/쓰기 선 활성화)

---

## 인터럽트 기반 입출력 (Interrupt-Driven I/O)

### 개요
- **장치 컨트롤러**가 하드웨어 인터럽트 발생
- **폴링 (Polling)**: 장치 상태를 CPU가 주기적으로 확인

---

### 동시다발적인 인터럽트
- 여러 장치에서 인터럽트가 동시에 발생할 수 있음
- **순차 처리**는 현실적으로 어렵고, **우선순위 고려 필요**

#### 우선순위를 반영한 인터럽트
- **NMI (Non-Maskable Interrupt)** 발생 시, 다른 인터럽트 무시하고 즉시 처리

### PIC (Programmable Interrupt Controller)
- 여러 장치 컨트롤러의 인터럽트 신호를 받아 **우선순위 판단**
- CPU에게 어떤 인터럽트를 먼저 처리할지 알려주는 하드웨어
- 일반적으로 **여러 개의 PIC** 사용
- **NMI 우선순위는 PIC가 판단하지 않음**

---

## DMA 입출력 (Direct Memory Access)

📌 프로그램 입출력 & 인터럽트 기반 입출력의 **공통점**  
→ **CPU가 직접 데이터 이동에 관여**, 반드시 CPU를 거침

### DMA의 핵심
- **CPU를 거치지 않고** 입출력장치가 메모리에 직접 접근
- **CPU의 역할**: 입출력 작업 시작/끝만 명령

### DMA 수행 과정
1. CPU가 DMA 컨트롤러에 명령
2. DMA 컨트롤러가 장치 컨트롤러와 상호작용
3. 입출력 작업 완료 시, DMA 컨트롤러가 **인터럽트로 CPU에 알림**

📌 **DMA와 시스템 버스**
- 시스템 버스는 공용 자원 → 동시에 CPU와 DMA가 사용 불가

### Cycle Stealing
- CPU가 시스템 버스를 쓰지 않을 때, DMA가 잠깐씩 사용
- CPU의 일시적 동의를 받고 버스를 사용

---

## 입출력 버스

### 문제점
- DMA 컨트롤러는 **시스템 버스를 2번 이용**  
  → ex. 메모리 → DMA → 장치 컨트롤러

### 해결: 입출력 버스
- 시스템 버스의 **사용 빈도 감소**
- **입출력 버스 종류**
  - PCI (Peripheral Component Interconnect) 버스
  - PCIe (PCI Express) 버스
- 여러 입출력 장치 → PCIe 슬롯에 연결

---

